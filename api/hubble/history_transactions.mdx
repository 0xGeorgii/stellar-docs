| Column Name | Type | Description |
| --- | --- | --- |
| id | int64 | A unique identifier for this transaction.<br /><br />- Primary Key<br />- Natural Key<br />- Cluster Field<br />- Required Field |
| transaction_hash | string | A hex-encoded SHA-256 hash of this transaction's XDR-encoded form.<br /><br />- Required Field |
| ledger_sequence | int64 | The sequence number of the ledger that this transaction was included in.<br /><br />- Cluster Field<br />- Required Field |
| account | string | The account address that originates the transaction.<br /><br />- Cluster Field<br />- Required Field |
| account_sequence | int64 | The source account's sequence number that this transaction consumed. Sequence numbers can only be used once and help maintain atomicity and idempotency on the network.<br /><br />- Required Field |
| max_fee | int64 | The maximum fee (in stroops) that the source account is willing to pay for the transaction to be included in a ledger. When the network enters surge pricing, this helps determine if a transaction is included in the set.<br /><br />- Required Field<br />#### Notes:<br />The stroop is the fractional representation of a lumen (XLM). 1 stroop is 0.0000001 XLM. |
| operation_count | int64 | The number of operations contained within this transaction.<br /><br />- Required Field<br />#### Notes:<br />A transaction is permitted to have up to 100 operations. |
| created_at | timestamp | The date the transaction was created. |
| memo_type | string | The type of memo.<br /><br />- Required Field<br /><br /><table> <thead> <tr> <th>Acceptable Values</th> </tr> </thead> <tbody> <tr> <td>MemoTypeMemoHash</td> </tr> <tr> <td>MemoTypeMemoId</td> </tr> <tr> <td>MemoTypeMemoNone</td> </tr> <tr> <td>MemoTypeMemoReturn</td> </tr> <tr> <td>MemoTypeMemoText</td> </tr> </tbody> </table><br />#### Notes:<br />Defaults to `MemoTypeMemoNone` |
| memo | string | An optional freeform field that attaches a memo to a transaction<br /><br />#### Notes:<br />Memos are heavily used by centralized exchanges to help with account management. |
| time_bounds | string | A transaction precondition that can be set to determine when a transaction is valid. The user can set a lower and upper timebound, defined as a UNIX timestamp when the transaction can be executed. <br />If the transaction attempts to execute outside of the time range, the transaction will fail |
| successful | bool | Indicates if this transaction was successful or not<br /><br />#### Notes:<br />A transaction's success does not indicate whether it was included and written to a ledger. It only indicates whether the operations in the transaction were successfully applied to mutate the ledger state. |
| fee_charged | int64 | The fee (in stroops) paid by the source account to apply this transaction to the ledger. At minimum, a transaction is charged # of operations * base fee. The minimum base fee is 100 stroops<br /><br />#### Notes:<br />The stroop is the fractional representation of a lumen (XLM). 1 stroop is 0.0000001 XLM. |
| inner_transaction_hash | string | AAAA |
| fee_account | string | An account that is not the originating source account for a transaction is allowed to pay transaction fees on behalf of the source account.<br />These accounts are called fee accounts and incur all transaction costs for the source account. |
| new_max_fee | int64 | If an account has a fee account, the fee account can specify a maximum fee (in stroops) that it is willing to pay for this account's fees.<br />When the network is in surge pricing, the validators will consider the new_max_fee instead of the max_fee when determining if the transaction will be included in the transaction set |
| account_muxed | string | If the user has defined multiplexed (muxed) accounts, the account exists "virtually" under a traditional Stellar account address.<br />This address distinguishes between the virtual accounts |
| fee_account_muxed | string | If the fee account that sponsors fee is a multiplexed account, the virtual address will be listed here |
| ledger_bounds | string | A transaction precondition that can be set to determine valid conditions for a transaction to be submitted to the network. <br />Ledger bounds allow the user to specify a minimum and maxiumum ledger sequence number in which the transaction can successfully execute |
| min_account_sequence | int64 | A transaction precondition that can be set to determine valid conditions for a transaction to be submitted to the network.<br />This condition contains an integer representation of the lowest source account sequence number for which the transaction is valid |
| min_account_sequence_age | int64 | A transaction precondition that can be set to determine valid conditions for a transaction to be submitted to the network. <br />This condition contains a minimum duration of time that must have passed since the source account's sequence number changed for the transaction to be valid |
| min_account_sequence_ledger_gap | int64 | A transaction precondition that can be set to determine valid conditions for a transaction to be submitted to the network. <br />This condition contains an integer representation of the minimum number of ledgers that must have closed since the source account's sequence number change for the transaction to be valid |
| extra_signers | record | An array of up to two additional signers that must have corresponding signatures for this transaction to be valid |
| tx_envelope | string | AAAA |
| tx_result | string | AAAA |
| tx_meta | string | AAAA |
| tx_fee_meta | string | AAAA |
| batch_id | string | String representation of the run id for a given DAG in Airflow. Takes the form of "scheduled__<batch_end_date>-<dag_alias>". Batch ids are unique to the batch and help with monitoring and rerun capabilities |
| batch_run_date | datetime | The start date for the batch interval. When taken with the date in the batch_id, the date represents the interval of ledgers processed. The batch run date can be seen as a proxy of closed_at for a ledger. |
| batch_insert_ts | timestamp | The timestamp in UTC when a batch of records was inserted into the database. This field can help identify if a batch executed in real time or as part of a backfill. The timestamp should not be used during ad hoc analysis and is useful for data engineering purposes. |
