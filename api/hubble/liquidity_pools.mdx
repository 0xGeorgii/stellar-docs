| Column Name | Type | Description |
| --- | --- | --- |
| liquidity_pool_id | string | Unique identifier for a liquidity pool. There cannot be duplicate pools for the same asset pair. Once a pool has been created for the asset pair, another cannot be created.<br /><br />- Natural Key<br />- Cluster Field<br />- Required Field<br /><br />#### Notes:<br />There is a good primer on AMMs [here](https://developers.stellar.org/docs/glossary/liquidity-pool?q=glossary+liquidity+pool). |
| type | string | The mechanism that calculates pricing and division of shares for the pool. With the initial AMM rollout, the only type of liquidity pool allowed to be created is a constant product pool.<br /><br />- Required Field<br /><br />#### Notes:<br />For more information regarding pricing and deposit calculations, read [Cap-38](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0038.md).<br /><br /><table> <thead> <tr> <th>Default Value</th> </tr> </thead> <tbody> <tr> <td>constant_product</td> </tr> </tbody> </table> |
| fee | int64 | The number of basis points charged as a percentage of the trade in order to complete the transaction. The fees earned on all trades are divided amongst pool shareholders and distributed as an incentive to keep money in the pools<br /><br />- Required Field<br /><br />#### Notes:<br />Fees are distributed immediately to accounts as the transaction completes. There is no schedule for fee distribution<br /><br /><table> <thead> <tr> <th>Default Value</th> </tr> </thead> <tbody> <tr> <td>30</td> </tr> </tbody> </table> |
| trustline_count | int64 | Total number of accounts with trustlines authorized to the pool. To create a trustline, an account must trust both base assets before trusting a pool with the asset pair.<br /><br />- Required Field<br /><br />#### Notes:<br />If the issuer of A or B revokes authorization on the trustline, the account will automatically withdraw from every liquidity pool containing that asset and those pool trustlines will be deleted. |
| pool_share_count | float64 | Participation in a liquidity pool is represented by a pool share.<br />The total number of pool shares is calculated by a constant product formula and is an arbitrary number representing the amount of participation in the pool.<br /><br />- Required Field<br /><br />#### Notes:<br />Shares are not transferable; the only way to increase the number of pool shares held is to deposit into a liquidity pool. Conversely, decreasing pools shares can only be accomplished through a withdraw operation. Shares cannot be sent in payments or sold using offers. |
| asset_a_type | string | The identifier for type of asset code, can be a alphanumeric with 4 characters, 12 characters or the native asset to the network, XLM.<br /><br />- Required Field |
| asset_a_code | string | The 4 or 12 character code representation of the asset of one of the two asset pairs in a liquidity pool |
| asset_a_issuer | string | The account address of the original asset issuer that created one of the two asset pairs in the liquidity pool |
| asset_a_amount | float64 | The raw number of tokens locked in the pool for one of the two asset pairs in the liquidity pool.<br /><br />- Required Field |
| asset_b_type | string | The identifier for type of asset code, can be a alphanumeric with 4 characters, 12 characters or the native asset to the network, XLM.<br /><br />- Required Field |
| asset_b_code | string | The 4 or 12 character code representation of the asset of one of the two asset pairs in a liquidity pool |
| asset_b_issuer | string | The account address of the original asset issuer that created one of the two asset pairs in the liquidity pool |
| asset_b_amount | float64 | The raw number of tokens locked in the pool for one of the two asset pairs in the liquidity pool.<br /><br />- Required Field |
| last_modified_ledger | int64 | The ledger sequence number when the ledger entry was last modified. Deletions do not count as a modification and will report the prior modification sequence number<br /><br />- Natural Key<br />- Cluster Field<br />- Required Field<br /><br />#### Notes:<br />As an example, if an account updates a signer's weight at sequence 1234 and then decides to delete the signer at 2345, the deleted record will still have a modified sequence of 1234. The `last_modified_ledger` **is not** a proxy for entry deletion time and should not be used in such a manner. Deletion times can be approximated with `batch_run_date`. |
| ledger_entry_change | int64 | Code that describes the ledger entry change type that was applied to the ledger entry.<br /><br />- Required Field<br /><br />#### Notes:<br />Not every ledger entry can be updated, some are only created or deleted. Pay attention to types that are not valid for certain ledger entries.<br /><br /><table> <thead> <tr> <th>Value</th> <th>Description</th> <th><strong>Not</strong> Valid For</th> </tr> </thead> <tbody> <tr> <td>0</td> <td>Ledger Entry Created</td> <td></td> </tr> <tr> <td>1</td> <td>Ledger Entry Updated</td> <td>claimable balances</td> </tr> <tr> <td>2</td> <td>Ledger Entry Deleted</td> <td></td> </tr> </tbody> </table> |
| deleted | bool | Indicates whether the ledger entry (account, claimable balance, trust line, offer, liquidity pool) has been deleted or not. Once an entry is deleted, it cannot be recovered.<br /><br />All state tables maintain history for deleted ledger entries.<br /><br />- Required Field |
| batch_id | string | String representation of the run id for a given DAG in Airflow. Takes the form of "scheduled__<batch_end_date>-<dag_alias>". Batch ids are unique to the batch and help with monitoring and rerun capabilities |
| batch_run_date | datetime | The start date for the batch interval. When taken with the date in the batch_id, the date represents the interval of ledgers processed. The batch run date can be seen as a proxy of closed_at for a ledger. |
| batch_insert_ts | timestamp | The timestamp in UTC when a batch of records was inserted into the database. This field can help identify if a batch executed in real time or as part of a backfill. The timestamp should not be used during ad hoc analysis and is useful for data engineering purposes. |
